/* compare_and_swap takes in a target destination that has a value, an old val
 * and a new val. This input exists on the stack, so the first thing we do
 * is move each input into a register. Nothing is added to the stack during
 * this code. The first input is at 4(%esp), which corresponds to 8(%ebp) when
 * we push the old base poitner and make the current stack the new base.
 * Similarily, the second input is at 12(%ebp) and the third is at 16(%ebp).
 * The code moves the second input into %eax, because the cmpxchg compares the
 * target value with whatever is in %eax. If they are equal, cmpxchg moves its
 * first argument into the second argument. If not, it does nothing (though
 * Zero Flag is set to reflect that they were not equal). We then use
 * jne to go to a block that moves 0 into %eax indicating failure. If they
 * are equal, we proceed in the compare_and_swap block and move 1 into %eax
 * indicating success. We then jump to return, which restores the stack and
 * returns whats in %eax.
 */


.globl compare_and_swap
.text
    .align 4

compare_and_swap:
    pushl   %ebp                /* Push old base pointer */
    movl    %esp, %ebp          /* Current stack is the new base. */

    movl    8(%ebp), %edx       /* Move the destination address into %ebx */
    movl    12(%ebp), %eax      /* Move the old value into %eax */
                                    /* cmpxchg will compare to this value. */
    movl    16(%ebp), %ebx      /* Move the new value into %ebx */

    lock cmpxchg %ebx, (%edx)   /* Compare the value at %eax (old val) with */
                                    /* the value at the destination address. */
                                    /* If equal, place %ebx into the dest */
                                    /* Else, do nothing. */
    jne     cmp_continue        /* If not equal, jump to continue. */

    movl    $1, %eax            /* Else, move 1 into %eax indicating success. */
    jmp     cmp_return          /* Jump to the return */
    .align 4                    /* This is generated by the compiler to align */
                                    /* code so that the CPU can process it */
                                    /* better. */

cmp_continue:
    movl    $0, %eax            /* Move 0 into %eax indicating failure. */


cmp_return:
    movl    %ebp, %esp          /* Pop local stack. */
    popl    %ebp                /* Pop old base frame. */
    ret                         /* Return statement. */

