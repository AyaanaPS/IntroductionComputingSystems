/* reverse_list takes in a linked list and returns the reversed version of 
 * the list. First, the code ensures that the list is not empty (by checking
 * the value of list->head to make sure it is not NULL). Then, it switches
 * the list->head and list->tail pointers. The code then moves into 
 * a loop, which switches all the pointers in the list (the pointers that point
 * to the next element) to make them switch to the previous element instead.
 * This function reverses the list in_place rather than creating a new list
 * consisting of the elements backwards. 
 * The input to the function exists on the stack. Nothing is added to the stack
 * during the adjustment of the list. 
 */

.globl reverse_list
.text
    .align 4

reverse_list:

    pushl %ebp          /* Push old base pointer */
    movl %esp, %ebp     /* Current stack is new base */

    movl 8(%ebp), %eax  /* We move the list argument into the eax register */

    movl (%eax), %ecx   /* We move the head pointer of the list into ecx */
    movl 4(%eax), %edx  /* We move the tail pointer of the list into edx */

    cmpl $0, %ecx       /* We compare the head pointer to 0 to check if it is */
                            /* NULL */
    je reverse_return   /* If the head is NULL, it means that the list is */
                            /* empty. Thus, we jump to reverse_return */
                            /* If it is not NULL, we proceed to reverse_switch*/
    .align 4            /* This is generated by the compiler to align */
                           /* code so that the CPU can process it better. */

reverse_switch:

    movl %edx, (%eax)   /* We move the old tail pointer into the head pointer */
    movl %ecx, 4(%eax)  /* We move the old head pointer into the tail pointer */

    movl $0, %edx       /* edx is the previous pointer, initially holding 0 */
    movl 4(%eax), %ecx   /* Move the current head of the list into the ecx */ 
                            /* register. This is our current pointer */
    movl $0, %eax       /* eax is the temp pointer, initially holding 0 */
    

reverse_loop:

    movl  4(%ecx), %eax /* This moves the initial current->next into a temp */
                            /* register for later use. */
    movl %edx, 4(%ecx)  /* This moves the current previous node into the */
                            /* current->next slot */
    movl %ecx, %edx     /* This moves the current node into the previous */
                            /* register */
    movl %eax, %ecx     /* This moves the temporary node stored before */
                            /* into the current node register for the next */
                            /* iteration. */

reverse_check:      
    
    cmpl $0, %ecx       /* This checks to see if the current node register */
                            /* is equal to NULL (0). */
    jne reverse_loop    /* If it is not NULL, we return to reverse_loop */
                            /* If it is NULL, we proceed to reverse_return */
    .align 4            /* This is generated by the compiler to align */
                           /* code so that the CPU can process it better. */

reverse_return:

    movl %ebp, %esp     /* Pop the local stack. */
    popl %ebp           /* Pop old base of frame */
    ret                 /* Return statement */



