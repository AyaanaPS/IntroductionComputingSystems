.globl gcd           /* Ignore everything beginning with a "." */
.text
    .align 4
gcd:
    pushl %ebp          /* Push old base pointer. */
    movl %esp,%ebp      /* Current stack is new base. */
    cmpl $0,12(%ebp)    /* See if arg2 equal zero. */
    jne gcd_continue    /* If not, continue. */
    movl 8(%ebp),%eax   /* Else result is arg1. */
    jmp gcd_return
    .align 4            /* This is generated by the compiler to align */
                           /* code so that the CPU can process it better. */
gcd_continue:
    movl 8(%ebp),%eax       /* eax has arg1 (a) */
    movl $0, %edx           /* edx has 0
    cltd                    /* edx:eax = a */
    idivl 12(%ebp)          /* Compute a/b */
    movl 12(%ebp), %eax     /* eax contains b */
    pushl %edx              /* edx contains the remainder, which is the new b */
    pushl %eax              /* eax contains b, which is the new a */    
    call gcd                /* Make recursive call */
    
gcd_return:
    movl %ebp,%esp     /* Pop local stack. */
    popl %ebp          /* Pop old base of frame. */
    ret                /* Return statement */
